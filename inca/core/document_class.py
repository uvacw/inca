'''
This document class is the template for classes that add or update
documents in the database. The scraper and update classes inherit
from this class.

The basic functionality is adding meta-data

'''

import logging
import datetime
import types
from celery import Task
from .search_utils import doctype_last, doctype_first
logger = logging.getLogger("INCA")

from .database import insert_document, insert_documents, update_document, check_exists

class Document(Task):
    '''
    Documents reflect the basic format of documents in the datastore.
    On save attempts, this class tries to infer whether required fields
    are present.

    The 'META' key contains a key:description of all other keys in the document.
    '''



    functiontype = '' # RSSscraper, text_processor, cluster_analysis, testing or other description of function
    version      = '' # string indicating version of function to track changes (e.g. "0.1")
    date         = datetime.datetime(year=1, day=1, month=1) # last function update date
    doctype      = '' # The doctype of documents generated by this function

    def runwrap(self, action='run', *args, **kwargs):
        '''
        Call the task as either a local or distributed process
        '''
        if action == 'run':
            return self.run(*args, **kwargs)

        if action == 'delay':
            return self.delay(*args, **kwargs)


    def __init__(self):
        '''
        intializes the document as either a document to be handled by the database or not
        '''
        pass

    def _save_document(self, document, forced=False):
        '''
        Documents are saved to the general document collection
        defined in the core.database file.

        Update existing documents by passing an elasticsearch results
        through the _update_document method.

        Note that by default, documents can only extend, not replace
        old documents.

        '''
        if type(document) == list:
            logger.debug("Detected document batch, forwarding to batch saver")
            self._save_documents(document, forced=forced)

        else:
            logger.debug("Saving individual document")
            assert self.doctype, "You need to declare a `self.doctype` in your subclass!"
            assert self.version, "You need to declare a `self.version` in your subclass!"
            assert self.functiontype, "You need to declare a `self.functiontype` in your subclass!"


            if '_id' in document.keys():
                custom_identifier = document.pop('_id')
            else :
                custom_identifier = None
            self._verify(document)
            insert_document(document, custom_identifier=custom_identifier)

    def _save_documents(self, documents, forced=False):
        """
        Handles a batch of multiple documents for efficient processing in ES.

        Functionality mirrors that of _save_document, but calls the batch_update
        on the list of documents rather than individually inserting them.
        """
        for document in documents:
            assert self.doctype, "You need to declare a `self.doctype` in your subclass!"
            assert self.version, "You need to declare a `self.version` in your subclass!"
            assert self.functiontype, "You need to declare a `self.functiontype` in your subclass!"


            if '_id' in document.keys():
                custom_identifier = document.pop('_id')
            else :
                custom_identifier = None
            self._verify(document)

        insert_documents(documents)

    def _update_document(self, new_document_body):
        '''
        This method updates exiting documents. It should map an elasticsearch
        result to a new body (the old body is in elasticsearch_result['_source']).
        '''
        update_document(new_document_body)

    def _add_metadata(self,document, **kwargs):
        '''
        DO NOT OVERWRITE THIS METHOD

        This method generates the metadata for returned documents based on
        the 'get' function docstring and arguments.

        All new keys are reflected in the 'META' key with the information
        about the script in question.

        '''
        if type(document)==list or isinstance(document, types.GeneratorType):
            return [self._add_metadata(doc) for doc in document]
        try:    docstring = self.get.__doc__
        except:
            try: docstring = self.process.__doc__
            except: docstring = self.run.__doc__
            
        document['doctype'] = self.doctype

        meta = dict(
            ADDED_AT              = datetime.datetime.now(),
            ADDED_USING           =str(self.__class__).split(' ')[1],
            ADDED_METHOD          = docstring,
            FUNCTION_VERSION      = self.version,
            FUNCTION_VERSION_DATE = self.date,
            FUNCTION_TYPE         = self.functiontype,
            FUNCTION_ARGUMENTS    = kwargs
            )

        if not document.get('META',False):
            document['META']=dict(ADDED=datetime.datetime.now())

        for key in document.keys():
            if key == 'META': continue
            if key not in document['META'].keys():
                document['META'][key] = meta

        return document

    def _verify(self, document):
        '''
        DO NOT OVERWRITE THIS METHOD

        This method verifies whether yielded documents conform to the specification
        of the datastore
        '''

        assert type(document)==dict
        assert document.get('META',False), "document lacks a `meta` key"
        for key in document.keys():
            if key=='META' or key=='doctype': continue
            #assert key in document['META'], "meta key for %s is missing from documents!" %key
            if key not in document['META']:
                logger.warn("{key} is missing from META !".format(**locals()))

    def _check_complete(self):
        '''
        DO NOT OVERWRITE THIS METHOD

        This method checks whether the appropriate information is present in the subclass.
        '''

        for attribute in ['functiontype','version','date','doctype']:
            if not getattr(self,attribute):
                logger.warning("""%s misses the appropriate `%s` property!
                Please set these in the class __init__ method as self.%s""" %(
                    self.__class__, attribute,attribute))

        teststrings = [''' This docstring should explain how documents are transformed ''',
                       ''' This docstring should explain how documents are retrieved ''' ]

        for method in ['process','get']:
            try:
                if getattr(self,method).__doc__ in teststrings:
                    logger.warning("""%s's %s docstring does not reflect functionality!
                    Please update the docstring in your class definition.""" %(self.__class__, method))
            except:
                pass

    def _check_exists(self, doc_id):
        '''Checks whether a document already exists, can be overwritten for testing etc '''
        return check_exists(doc_id)

    def _last_added(self):
        '''returns last added document of class'''
        last = doctype_last(self.doctype)
        if last:
            return last[0]
        else:
            return {}

    def _first_added(self):
        '''returns the first added document (for backward scraping scrapers)'''
        first = doctype_first(self.doctype)
        if first:
            return first[0]
        else:
            return {}
